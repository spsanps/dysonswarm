<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dyson Swarm — A Megastructure Visualization</title>

  <!-- SEO Meta -->
  <meta name="description" content="An interactive visualization of a Dyson swarm — a megastructure of countless satellites orbiting the sun, capturing its energy. Watch Mercury being disassembled to build the swarm.">
  <meta name="keywords" content="dyson swarm, dyson sphere, megastructure, space, visualization, interactive, mercury, solar energy, sci-fi">
  <meta name="author" content="dysonswarm.com">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://dysonswarm.com">

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://dysonswarm.com">
  <meta property="og:title" content="Dyson Swarm — A Megastructure Visualization">
  <meta property="og:description" content="An interactive visualization of a Dyson swarm — countless satellites orbiting the sun, capturing its energy. Watch Mercury being disassembled to build humanity's greatest megastructure.">
  <meta property="og:image" content="https://dysonswarm.com/og-image.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:site_name" content="Dyson Swarm">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content="https://dysonswarm.com">
  <meta name="twitter:title" content="Dyson Swarm — A Megastructure Visualization">
  <meta name="twitter:description" content="An interactive visualization of a Dyson swarm — countless satellites orbiting the sun, capturing its energy.">
  <meta name="twitter:image" content="https://dysonswarm.com/og-image.png">

  <!-- Theme & Icons -->
  <meta name="theme-color" content="#000000">
  <meta name="msapplication-TileColor" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Dyson Swarm">

  <!-- Favicon SVG -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='35' fill='%23e6b84d'/%3E%3Ccircle cx='50' cy='50' r='25' fill='%23f0c860'/%3E%3Ccircle cx='50' cy='50' r='15' fill='%23f5d980'/%3E%3Ccircle cx='30' cy='35' r='2' fill='%23222'/%3E%3Ccircle cx='55' cy='28' r='1.5' fill='%23222'/%3E%3Ccircle cx='70' cy='45' r='2' fill='%23222'/%3E%3Ccircle cx='65' cy='65' r='1.5' fill='%23222'/%3E%3Ccircle cx='40' cy='70' r='2' fill='%23222'/%3E%3Ccircle cx='25' cy='55' r='1.5' fill='%23222'/%3E%3C/svg%3E">
  <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect fill='%23000' width='100' height='100'/%3E%3Ccircle cx='50' cy='50' r='35' fill='%23e6b84d'/%3E%3Ccircle cx='50' cy='50' r='25' fill='%23f0c860'/%3E%3C/svg%3E">

  <!-- Preconnect -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
    body { font-family: 'Instrument Serif', Georgia, serif; }
    canvas {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .title {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      text-align: center;
      pointer-events: none;
    }
    .title h1 {
      font-size: clamp(28px, 4vw, 48px);
      font-weight: 400;
      font-style: italic;
      color: #aa8866;
      opacity: 0;
      animation: fadeUp 3s ease 0.5s forwards;
    }
    .info {
      position: fixed;
      top: 30px;
      right: 30px;
      max-width: 280px;
      z-index: 10;
      text-align: right;
      pointer-events: none;
    }
    .info p {
      font-size: 11px;
      line-height: 1.8;
      color: #443322;
      opacity: 0;
      animation: fadeUp 3s ease 2.5s forwards;
    }
    .info .highlight {
      color: #886644;
    }
    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(15px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .slider-container {
      position: fixed;
      top: 145px;
      right: 30px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
      opacity: 0;
      animation: fadeUp 2s ease 3s forwards;
    }
    .slider-label {
      font-size: 10px;
      color: #554433;
      letter-spacing: 0.1em;
    }
    .slider {
      -webkit-appearance: none;
      width: 140px;
      height: 2px;
      background: #332211;
      outline: none;
      cursor: pointer;
    }
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: #886644;
      border-radius: 50%;
      cursor: pointer;
    }
    .slider::-moz-range-thumb {
      width: 12px;
      height: 12px;
      background: #886644;
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="slider-container">
    <input type="range" min="0" max="100" value="50" class="slider" id="disassembly">
    <div class="slider-label">disassembly</div>
  </div>
  <div class="title"><h1>Dyson Swarm</h1></div>
  <div class="info">
    <p>
      A <span class="highlight">Dyson swarm</span> is a megastructure of
      countless satellites orbiting a star, capturing its energy.
      <span class="highlight">Mercury</span> is being disassembled —
      its matter launched outward to construct the swarm.
      In time, the sun's face will bloom like a sunflower.
    </p>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const slider = document.getElementById('disassembly');

    const PIXEL = 2;
    let width, height, gridW, gridH, centerX, centerY;
    let time = 0;
    let disassemblyLevel = 0.5; // 0-1, starts halfway

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      gridW = Math.ceil(width / PIXEL);
      gridH = Math.ceil(height / PIXEL);
      centerX = gridW / 2;
      centerY = gridH / 2;
      canvas.width = gridW;
      canvas.height = gridH;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.imageSmoothingEnabled = false;
    }

    function gray(level, alpha = 1) {
      const v = Math.floor(Math.max(0, Math.min(1, level)) * 255);
      return `rgba(${v},${v},${v},${alpha})`;
    }

    function sun(level, alpha = 1) {
      const l = Math.max(0, Math.min(1, level));
      const r = Math.floor(255 * (0.92 + l * 0.08));
      const g = Math.floor(255 * (0.7 + l * 0.25));
      const b = Math.floor(255 * (0.3 + l * 0.2));
      return `rgba(${r},${g},${b},${alpha})`;
    }

    function fillCircle(cx, cy, r, color) {
      ctx.fillStyle = color;
      const r2 = r * r;
      for (let y = -Math.ceil(r); y <= Math.ceil(r); y++) {
        for (let x = -Math.ceil(r); x <= Math.ceil(r); x++) {
          if (x*x + y*y <= r2) {
            ctx.fillRect(Math.floor(cx + x), Math.floor(cy + y), 1, 1);
          }
        }
      }
    }

    function seededRandom(seed) {
      const x = Math.sin(seed * 9999) * 10000;
      return x - Math.floor(x);
    }

    // Camera
    const camera = {
      rotY: 0,
      rotX: 0.3,
      dist: 380,
      fov: 320
    };

    function project(x, y, z) {
      const cosY = Math.cos(camera.rotY);
      const sinY = Math.sin(camera.rotY);
      let rx = x * cosY - z * sinY;
      let rz = x * sinY + z * cosY;
      let ry = y;

      const cosX = Math.cos(camera.rotX);
      const sinX = Math.sin(camera.rotX);
      let ry2 = ry * cosX - rz * sinX;
      let rz2 = ry * sinX + rz * cosX;

      rz2 += camera.dist;

      if (rz2 <= 5) return null;
      const scale = camera.fov / rz2;
      const sx = centerX + rx * scale;
      const sy = centerY + ry2 * scale;

      return { x: sx, y: sy, z: rz2, scale, worldZ: rz };
    }

    // Swarm - satellite count depends on disassembly level
    const satellites = [];
    const MIN_SATELLITES = 500;
    const MAX_SATELLITES = 8000;

    function getTargetSatellites() {
      return Math.floor(MIN_SATELLITES + disassemblyLevel * (MAX_SATELLITES - MIN_SATELLITES));
    }

    function createSatellite(fromMercury = false, mercuryPos = null) {
      let radius, theta, phi;

      if (fromMercury && mercuryPos) {
        radius = mercuryPos.r;
        theta = mercuryPos.theta + (Math.random() - 0.5) * 0.3;
        phi = mercuryPos.phi + (Math.random() - 0.5) * 0.3;
      } else {
        // Uniform distribution across radius range
        radius = 50 + Math.random() * 200;
        theta = Math.random() * Math.PI * 2;
        phi = Math.acos(2 * Math.random() - 1); // Uniform sphere
      }

      return {
        radius,
        targetRadius: 50 + Math.random() * 200,
        theta,
        phi,
        // Faster orbital speeds
        speedTheta: (0.00015 + Math.random() * 0.0002) * (100 / Math.max(50, radius)),
        speedPhi: (Math.random() - 0.5) * 0.00005,
        glintOffset: Math.random() * 10000
      };
    }

    function getSatellitePos(sat) {
      const r = sat.radius;
      const x = r * Math.sin(sat.phi) * Math.cos(sat.theta);
      const y = r * Math.cos(sat.phi);
      const z = r * Math.sin(sat.phi) * Math.sin(sat.theta);
      return { x, y, z };
    }

    // Mercury - expanded orbit, size depends on disassembly
    const mercury = {
      semiMajor: 110,
      eccentricity: 0.35,
      angle: 0,
      speed: 0.00005,
      inclination: 0.12,
      maxSize: 4.5
    };

    function getMercurySize() {
      return mercury.maxSize * (1 - disassemblyLevel * 0.9);
    }

    function getMercuryPos() {
      const r = mercury.semiMajor * (1 - mercury.eccentricity * mercury.eccentricity) /
                (1 + mercury.eccentricity * Math.cos(mercury.angle));
      const x = r * Math.cos(mercury.angle);
      const z = r * Math.sin(mercury.angle) * Math.cos(mercury.inclination);
      const y = r * Math.sin(mercury.angle) * Math.sin(mercury.inclination);
      const theta = Math.atan2(z, x);
      const phi = Math.acos(y / Math.max(0.1, r));
      return { x, y, z, r, theta, phi };
    }

    // Debris
    const debris = [];

    // Sunspots - slow moving dark regions
    const sunspots = [];
    for (let i = 0; i < 5; i++) {
      sunspots.push({
        angle: Math.random() * Math.PI * 2,
        lat: (Math.random() - 0.5) * 0.6,
        size: 1.5 + Math.random() * 2.5,
        speed: 0.000008 + Math.random() * 0.000005,
        life: Math.random()
      });
    }

    // Solar flares - slow eruptions
    const flares = [];
    for (let i = 0; i < 4; i++) {
      flares.push({
        angle: (i / 4) * Math.PI * 2,
        phase: Math.random() * Math.PI * 2,
        baseLength: 3 + Math.random() * 5,
        speed: 0.0003 + Math.random() * 0.0002
      });
    }

    // Stars
    const stars = [];
    function generateStars() {
      stars.length = 0;
      for (let i = 0; i < 500; i++) {
        stars.push({
          x: Math.random() * gridW,
          y: Math.random() * gridH,
          b: 0.04 + Math.random() * 0.18,
          t: Math.random() * Math.PI * 2,
          ts: 0.0002 + Math.random() * 0.0005
        });
      }
    }

    function init() {
      generateStars();
      const initial = getTargetSatellites();
      for (let i = 0; i < initial; i++) {
        satellites.push(createSatellite(false));
      }
    }

    // Slider control
    slider.addEventListener('input', (e) => {
      disassemblyLevel = e.target.value / 100;
    });

    const SUN_RADIUS = 25;
    const SUN_TRANSIT_RADIUS = 32;

    function update(dt) {
      // Very slow camera
      camera.rotY += dt * 0.0000025;
      camera.rotX = 0.22 + Math.sin(time * 0.00001) * 0.12;

      mercury.angle += mercury.speed * dt;

      // Spawn debris - more when actively disassembling
      const debrisRate = 0.02 + disassemblyLevel * 0.08;
      if (Math.random() < debrisRate && getMercurySize() > 0.5) {
        const mPos = getMercuryPos();
        const dir = Math.sqrt(mPos.x*mPos.x + mPos.y*mPos.y + mPos.z*mPos.z);
        for (let i = 0; i < 2; i++) {
          debris.push({
            x: mPos.x, y: mPos.y, z: mPos.z,
            vx: (mPos.x / dir) * 0.006 + (Math.random() - 0.5) * 0.004,
            vy: (mPos.y / dir) * 0.006 + (Math.random() - 0.5) * 0.004,
            vz: (mPos.z / dir) * 0.006 + (Math.random() - 0.5) * 0.004,
            life: 1.0
          });
        }
      }

      for (let i = debris.length - 1; i >= 0; i--) {
        const d = debris[i];
        d.x += d.vx * dt;
        d.y += d.vy * dt;
        d.z += d.vz * dt;
        d.life -= dt * 0.00008;
        if (d.life <= 0) debris.splice(i, 1);
      }

      // Update satellites
      for (const sat of satellites) {
        sat.theta += sat.speedTheta * dt;
        sat.phi += sat.speedPhi * dt;
        if (sat.phi < 0.15) { sat.phi = 0.15; sat.speedPhi *= -1; }
        if (sat.phi > Math.PI - 0.15) { sat.phi = Math.PI - 0.15; sat.speedPhi *= -1; }
        sat.radius += (sat.targetRadius - sat.radius) * 0.000003 * dt;
      }

      // Update sunspots
      for (const spot of sunspots) {
        spot.angle += spot.speed * dt;
        spot.life += dt * 0.00002;
        if (spot.life > 1) {
          spot.life = 0;
          spot.lat = (Math.random() - 0.5) * 0.6;
          spot.size = 1.5 + Math.random() * 2.5;
        }
      }

      // Update flares
      for (const flare of flares) {
        flare.phase += flare.speed * dt;
        flare.angle += dt * 0.000003;
      }

      // Maintain count based on disassembly level
      const target = getTargetSatellites();
      while (satellites.length < target) {
        const mPos = getMercuryPos();
        satellites.push(createSatellite(true, mPos));
      }
      // Remove excess if slider moved back
      while (satellites.length > target) {
        satellites.pop();
      }
    }

    function isTransit(screenX, screenY, worldZ) {
      const dx = screenX - centerX;
      const dy = screenY - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      return dist < SUN_TRANSIT_RADIUS && worldZ < 0;
    }

    function isBehindSun(screenX, screenY, worldZ) {
      const dx = screenX - centerX;
      const dy = screenY - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      return dist < SUN_RADIUS - 3 && worldZ > 0;
    }

    function drawStars() {
      for (const s of stars) {
        const twinkle = Math.sin(time * s.ts + s.t) * 0.06;
        ctx.fillStyle = gray(s.b + twinkle);
        ctx.fillRect(Math.floor(s.x), Math.floor(s.y), 1, 1);
      }
    }

    function drawSunGlow() {
      // Outer halo
      for (let r = SUN_RADIUS + 60; r > SUN_RADIUS + 10; r -= 4) {
        const t = (r - SUN_RADIUS - 10) / 50;
        const alpha = 0.025 * Math.pow(1 - t, 2);
        fillCircle(centerX, centerY, r, sun(0.1, alpha));
      }
      // Corona
      for (let r = SUN_RADIUS + 12; r > SUN_RADIUS; r -= 1) {
        const t = (r - SUN_RADIUS) / 12;
        const alpha = 0.3 * (1 - t);
        fillCircle(centerX, centerY, r, sun(0.3, alpha));
      }
    }

    function drawSunBody() {
      // Main body
      fillCircle(centerX, centerY, SUN_RADIUS, sun(0.55));
      fillCircle(centerX, centerY, SUN_RADIUS - 2, sun(0.65));
      fillCircle(centerX, centerY, SUN_RADIUS - 4, sun(0.75));
      fillCircle(centerX, centerY, SUN_RADIUS - 6, sun(0.85));
      fillCircle(centerX, centerY, SUN_RADIUS - 8, sun(0.95));
      fillCircle(centerX, centerY, SUN_RADIUS - 10, sun(1.0));

      // Granulation - subtle surface texture
      for (let i = 0; i < 12; i++) {
        const a = (i / 12) * Math.PI * 2 + time * 0.000015;
        const r = SUN_RADIUS - 16 + Math.sin(i * 1.7 + time * 0.00003) * 3;
        const px = centerX + Math.cos(a) * r;
        const py = centerY + Math.sin(a) * r;
        fillCircle(px, py, 1 + Math.sin(i * 2.3) * 0.5, sun(0.5, 0.4));
      }

      // Sunspots - dark regions
      for (const spot of sunspots) {
        const visible = Math.cos(spot.angle - camera.rotY);
        if (visible > 0) {
          const x = Math.sin(spot.angle - camera.rotY) * (SUN_RADIUS - 8) * (1 - Math.abs(spot.lat));
          const y = spot.lat * (SUN_RADIUS - 8);
          const apparentSize = spot.size * visible * (0.5 + spot.life * 0.5);
          if (apparentSize > 0.5) {
            fillCircle(centerX + x, centerY + y, apparentSize, sun(0.25, 0.7 * visible));
            fillCircle(centerX + x, centerY + y, apparentSize * 0.5, sun(0.15, 0.8 * visible));
          }
        }
      }

      // Slow solar flares
      for (const flare of flares) {
        const intensity = (Math.sin(flare.phase) + 1) * 0.5;
        if (intensity > 0.3) {
          const len = flare.baseLength * intensity;
          const angle = flare.angle;
          const sx = centerX + Math.cos(angle) * SUN_RADIUS;
          const sy = centerY + Math.sin(angle) * SUN_RADIUS;

          // Flare arc
          for (let i = 0; i < len; i += 1) {
            const t = i / len;
            const curve = Math.sin(t * Math.PI) * 3;
            const fx = sx + Math.cos(angle) * i + Math.cos(angle + Math.PI/2) * curve;
            const fy = sy + Math.sin(angle) * i + Math.sin(angle + Math.PI/2) * curve;
            const alpha = (1 - t) * intensity * 0.6;
            fillCircle(fx, fy, 1.5 - t, sun(0.6, alpha));
          }
        }
      }
    }

    function drawSwarm() {
      const projected = [];

      for (const sat of satellites) {
        const pos = getSatellitePos(sat);
        const proj = project(pos.x, pos.y, pos.z);
        if (!proj) continue;
        if (proj.x < -20 || proj.x > gridW + 20 || proj.y < -20 || proj.y > gridH + 20) continue;

        const transit = isTransit(proj.x, proj.y, proj.worldZ);
        const behind = isBehindSun(proj.x, proj.y, proj.worldZ);

        projected.push({ sat, proj, transit, behind });
      }

      projected.sort((a, b) => b.proj.z - a.proj.z);

      // Non-transiting
      for (const { sat, proj, transit, behind } of projected) {
        if (behind || transit) continue;

        const depthFade = Math.max(0.2, 1 - proj.z / 500);
        const glint = Math.sin(time * 0.0008 + sat.glintOffset) > 0.96 ? 0.25 : 0;
        const brightness = 0.15 + depthFade * 0.5 + glint;

        ctx.fillStyle = gray(brightness);
        ctx.fillRect(Math.floor(proj.x), Math.floor(proj.y), 1, 1);
      }

      return projected;
    }

    function drawTransits(projected) {
      ctx.fillStyle = gray(0.1);
      for (const { sat, proj, transit, behind } of projected) {
        if (!transit || behind) continue;

        // Uniform 1x1 dark silhouettes
        ctx.fillRect(Math.floor(proj.x), Math.floor(proj.y), 1, 1);
      }
    }

    function drawMercury() {
      const mercurySize = getMercurySize();
      if (mercurySize < 0.5) return; // Fully disassembled

      const pos = getMercuryPos();
      const proj = project(pos.x, pos.y, pos.z);
      if (!proj) return;

      if (isBehindSun(proj.x, proj.y, proj.worldZ)) return;

      const size = Math.max(1, mercurySize * proj.scale / 2);

      if (isTransit(proj.x, proj.y, proj.worldZ)) {
        fillCircle(proj.x, proj.y, size, gray(0.06));
      } else {
        fillCircle(proj.x, proj.y, size, gray(0.32));
        if (size > 1.5) {
          fillCircle(proj.x - size * 0.25, proj.y - size * 0.15, size * 0.6, gray(0.45));
        }
        // Mining glow - more intense when being disassembled
        const glowIntensity = 0.1 + disassemblyLevel * 0.15;
        const glow = glowIntensity + Math.sin(time * 0.001) * 0.06;
        fillCircle(proj.x, proj.y, size + 2, sun(0.2, glow));
      }
    }

    function drawDebris() {
      for (const d of debris) {
        const proj = project(d.x, d.y, d.z);
        if (!proj) continue;
        if (isBehindSun(proj.x, proj.y, proj.worldZ)) continue;

        const brightness = isTransit(proj.x, proj.y, proj.worldZ) ? 0.08 : 0.3 * d.life;
        ctx.fillStyle = gray(brightness, d.life * 0.7);
        ctx.fillRect(Math.floor(proj.x), Math.floor(proj.y), 1, 1);
      }
    }

    resize();
    init();
    window.addEventListener('resize', () => { resize(); generateStars(); });

    let lastTime = 0;
    function animate(timestamp) {
      const dt = Math.min(50, timestamp - lastTime);
      lastTime = timestamp;
      time = timestamp;

      update(dt);

      ctx.fillStyle = '#010102';
      ctx.fillRect(0, 0, gridW, gridH);

      drawStars();
      drawSunGlow();
      const projected = drawSwarm();
      drawSunBody();
      drawTransits(projected);
      drawDebris();
      drawMercury();

      requestAnimationFrame(animate);
    }

    animate(0);
  </script>
</body>
</html>
